var probe = require("../index").start();
var mathModule = require('./test_modules/math');
var math = new mathModule();
var proxy = require('../lib/proxy');
var virtualstack = require('../lib/virtualstack');
var instUtil = require('../lib/utils/instrument-util');
const assert = require('assert');

describe('instrument-util', function () {
    beforeEach(function () {
        math = new mathModule();
    });

    afterEach(function () {
        virtualstack.setTraceHandlers(null, null);
    });

    after(function () {
    });

    describe('.instrumentSync()', function () {
        it('should insert before and after hook ', function () {
            var startObj = null, startArgs = null, finishObj = null, finishArgs = null, returnVal = null;

            instUtil.instrumentSync(math, ['add'], null, function getParamsForStartEvent(obj, args) {
                startObj = obj;
                startArgs = args;
                return args;
            }, function getParamsForFinishEvent(obj, args, rval) {
                finishObj = obj;
                finishArgs = args;
                returnVal = rval;
                return rval;
            });

            // call instrumented function
            var x = 2, y = 3;
            var result = math.add(x, y);
            assert.equal(startObj, math, 'incorrect object passed to start-event callback');
            assert.ok(startArgs[0] == x && startArgs[1] == y, 'incorrect function arguments passed to start-event callback');
            assert.equal(finishObj, math, 'incorrect object passed to finish-event callback');
            assert.ok(finishArgs[0] == x && finishArgs[1] == y, 'incorrect function arguments passed to finish-event callback');
            assert.equal(returnVal, result, 'incorrect return value');
        });

        it('instrument array of functions', function () {
            var count = 0;

            instUtil.instrumentSync(math, ['add', 'subtract'], null, function getParamsForStartEvent(obj, args) {
                count++;
                return args;
            });

            // call instrumented function
            var x = 2, y = 3;
            math.add(x, y);
            math.subtract(x, y);
            assert.equal(count, 2, 'not all functions in array got instrumnted');
        });
    });

    describe('.instrumentAsync()', function () {
        it('should insert before and callback hook ', function () {
            var startObj = null, startArgs = null, finishObj = null, returnVal = null;

            instUtil.instrumentAsync(math, ['execute'], null, function getParamsForStartEvent(obj, args) {
                startObj = obj;
                startArgs = args;
                return args;
            }, function getParamsForFinishEvent(obj, args) {
                finishObj = obj;
                returnVal = args[1];
                return rval;
            });

            // call instrumented function
            var x = 2, y = 3;
            var result;
            math.execute('add', x, y, function (error, val) {
                result = val;
            });

            assert.equal(startObj, math, 'incorrect object passed to start-event callback');
            assert.ok(startArgs[0] == 'add' && startArgs[1] == x && startArgs[2] == y, 'incorrect function arguments passed to start-event callback');
            assert.equal(returnVal, result, 'incorrect return value');
        });

        it('instrument array of functions', function () {
            var count = 0;

            instUtil.instrumentAsync(math, ['execute', 'compute'], null, function getParamsForStartEvent(obj, args) {
                count++;
                return args;
            });

            // call instrumented function
            var x = 2, y = 3;
            math.compute('add', x, y, function (error, val) {
            });
            assert.equal(count, 2, 'not all functions in array got instrumnted');
        });

        it('should create errorObject on failure', function (done) {
            instUtil.instrumentAsync(math, ['execute']);

            virtualstack.setTraceHandlers(function startTrace(name, time, txid, evtid, params) {
            }, function endTrace(name, time, txid, evtid, params, errormsg) {

                if (errormsg.class === 'Error' && JSON.stringify(errormsg).indexOf('Invalid Arguments') != -1) {
                    done();
                }
            });

            // call instrumented function
            var x = -1, y = 3;
            var result;
            math.execute('add', x, y, function (error, val) {
                result = val;
            });
        });
    });


    describe('.instrumentAsyncPromise()', function () {
        it('should insert before and promise hook ', function () {
            var startObj = null, startArgs = null, returnVal = null;

            instUtil.instrumentAsyncPromise(math, ['calculate'], null, function getParamsForStartEvent(obj, args) {
                startObj = obj;
                startArgs = args;
                return args;
            }, function getParamsForFinishEvent(val) {
                returnVal = val;
                return rval;
            });

            // call instrumented function
            var x = 2, y = 3;
            var result;
            var promise = math.calculate('add', x, y);
            promise.then(function (val) {
                result = val;
            });

            assert.equal(startObj, math, 'incorrect object passed to start-event callback');
            assert.ok(startArgs[0] == 'add' && startArgs[1] == x && startArgs[2] == y, 'incorrect function arguments passed to start-event callback');
            assert.equal(returnVal, result, 'incorrect return value');
        });

        it('should create errorObject on promise rejection', function (done) {
            instUtil.instrumentAsyncPromise(math, ['calculate']);

            virtualstack.setTraceHandlers(function startTrace(name, time, txid, evtid, params) {
            }, function endTrace(name, time, txid, evtid, params, errormsg) {

                if (errormsg.class === 'Error' && JSON.stringify(errormsg).indexOf('Invalid Arguments') != -1) {
                    done();
                }
            });

            // call instrumented function
            var x = -1, y = 3;
            var result;
            var promise = math.calculate('add', x, y);
            promise.then(function (val) {
                result = val;
            }).catch(function (reason) {
                //console.log('error ' + reason);
            });

        });
    });


});

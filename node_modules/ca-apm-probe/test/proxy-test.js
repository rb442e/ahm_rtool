var mathModule = require('./test_modules/math');
var math = new mathModule();
var proxy = require('../lib/proxy');
const assert = require('assert');


describe('Proxy', function () {
    beforeEach(function () {
        math = new mathModule();
    });

    afterEach(function () {

    });

    describe('.before()', function () {
        it('should insert before hook ', function () {
            var called = false;

            //instrument by adding probe
            proxy.before(math, 'add',
                function beforeHook(obj, args) {
                    called = true;
                });

            // call instrumented function
            math.add(2, 3);
            assert.equal(called, true, 'insert hook is not called');
        });

        it('object and arguments are accessible', function () {
            var testObj, testArgs = null;

            //instrument by adding probe
            proxy.before(math, 'add',
                function beforeHook(obj, args) {
                    testObj = obj;
                    testArgs = args;
                });

            // call instrumented function
            math.add(2, 3);
            assert.equal(testObj, math, 'unexpected obj argument');
            assert.notEqual(testArgs, null, 'invalid arguments');
            assert.equal(testArgs[0], 2, 'invalid first argument');
            assert.equal(testArgs[1], 3, 'invalid second argument');
        });

    });

    describe('.after()', function () {

        it('should insert after hook ', function () {
            var called = false;

            //instrument by adding probe
            proxy.after(math, 'add',
                function afterHook(obj, args) {
                    called = true;
                });

            // call instrumented function
            math.add(2, 3);
            assert.equal(called, true, 'after hook is not called');

        });

        it('object, arguments and return value are accessible', function () {
            var testObj, testArgs, retValue = null;

            //instrument by adding probe
            proxy.after(math, 'add',
                function afterHook(obj, args, rVal) {
                    testObj = obj;
                    testArgs = args;
                    retValue = rVal;
                });

            // call instrumented function
            var r = math.add(2, 3);
            assert.equal(testObj, math, 'unexpected obj argument');
            assert.notEqual(testArgs, null, 'invalid arguments');
            assert.equal(testArgs[0], 2, 'invalid first argument');
            assert.equal(testArgs[1], 3, 'invalid second argument');
            assert.equal(retValue, r, 'unexpected return value');
        });

    });

    describe('.around()', function () {
        it('should insert hooks around ', function () {
            var counter = 0;

            //instrument by adding probe befor and after probes
            proxy.around(math, 'add',
                function beforeHook(obj, args) {
                    counter++;
                }, function afterHook(obj, args) {
                    counter++;
                });

            // call instrumented function
            math.add(2, 3);
            assert.equal(counter, 2, 'Either one of the hooks(before/after) or both are not called');

        });

        it('validate order of execution', function () {
            var counter = 0;

            //instrument by adding probes around
            proxy.around(math, 'add',
                function beforeHook(obj, args) {
                    counter++;
                }, function afterHook(obj, args) {
                    if (counter > 0) counter++;
                });

            // call instrumented function
            math.add(2, 3);
            assert.equal(counter, 2, 'incorrect order of execution for hooks');
        });

    });

});

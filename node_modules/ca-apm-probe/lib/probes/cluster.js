 
/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */
var config = require('../../config.json');
var logger = require("../logger.js");

var util = require('util');

//var cluster = require('cluster');

function addWorker(map, id) {
	// Look foor empty spot first
	var i;
	for (i = 0; i < map.length; i++) {
		if (map[i] == 0) {
			break;
		}
	}
	// add id as last element
	map[i] = id;
	return i + 1;
};

function removeWorker(map, id) {
	var i;
	for (i = 0; i < map.length; i++) {
		if (map[i] == id) {
			map[i] = 0;
			return;
		}
	}	
};

module.exports = function(cluster) {
	if ('CAAPMPROBESET' in cluster) {
		  return;
	}
	logger.info('Loading cluster probe');
	Object.defineProperty(cluster, 'CAAPMPROBESET', {value: 0});
	if (cluster.isMaster) {
		logger.info('cluster probe: master');
		var workermap = new Array();
		cluster.on('fork', function(worker) {
			var num = addWorker(workermap, worker.id);
			logger.info('cluster probe: Forked child %d assigned num: %d', worker.id, num);
			worker.send({cmd : 'setWorkerNum', workerNum: num});
		});		
		cluster.on('online', function(worker) {
			logger.info('cluster probe: online child %d', worker.id);
		});				
		cluster.on('disconnect', function(worker) {
			logger.info('cluster probe: disconnected child %d', worker.id);
		});				
		cluster.on('message', function(worker) {
			logger.info('cluster probe: message from child %d', worker.id);
		});				
		cluster.on('listening', function(worker) {
			logger.info('cluster probe: listening child %d', worker.id);
		});				
		cluster.on('exit', function(worker) {
			removeWorker(workermap, worker.id);
			logger.info('cluster probe: exit child %d', worker.id);
		});				
	}
	else {
		logger.info('cluster probe: Worker id=%d', cluster.worker.id);
		var workerIdEnvKey = config.workerIdEnvKey;
		var workerNum;
		if (workerIdEnvKey && workerIdEnvKey.length > 0) {
			workerNum = process.env[workerIdEnvKey];
		}
		if (workerNum && workerNum.length > 0) {
			logger.setLabel('worker' + workerNum);
			logger.info('cluster probe: Worker id=%d assigned num=%d', cluster.worker.id, workerNum);
			Object.defineProperty(cluster, 'CAAPMPROBE_WORKERNUM', {value: workerNum});			
		}
		else {
			process.on('message', function(msg) {
				if (msg.cmd && msg.cmd === 'setWorkerNum') {
					logger.setLabel('worker' + msg.workerNum);
					logger.info('cluster probe: Worker id=%d assigned num=%d', cluster.worker.id, msg.workerNum);
					Object.defineProperty(cluster, 'CAAPMPROBE_WORKERNUM', {value: msg.workerNum});
				}
				else {
					logger.debug('cluster probe: unknown message' + util.inspect(msg, { showHidden: true, depth: null }));				
				}
			});
			
		}
	}
};

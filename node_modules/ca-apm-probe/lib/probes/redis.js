 
/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

var agent = require('../agent');
var logger = require("../logger.js");
var proxy = require('../proxy');

function instrument(methodMap)

{
  // logger.info('redis: instrument()');
  var redis = this.targetModule;

  proxy.before(redis.RedisClient.prototype, 'send_command',
               function(obj, args, storage) {
    if (agent.paused) return;


    var command = args[0];
    var input = args[1];

    if (!Array.isArray(input)) return;
    /*
    var query = command +
                (typeof input[0] === 'string' ? ' "' + input[0] + '"' : '');

    var eventNameFormatted = 'redis.' + command;
    */
    var ctx = storage.get('ctx');
    if (ctx != null) {
        /*
        logger.debug('%s[%d %d %d]: %s', eventNameFormatted, ctx.txid, ctx.lane, ctx.evtid, query);
    	ctx = agent.asynchEventStart(ctx, eventNameFormatted, { query: ''});
    	*/
        storage.set('ctx', ctx);
    }


    function handle(obj, args, storage) {
     // var errorObject = agent.checkAndSetErrorObject(args, 'RedisError');
      
      if (ctx != null) {
        /*
        logger.debug('%s[%d %d %d]: callback', eventNameFormatted, ctx.txid, ctx.lane, ctx.evtid);
      	ctx = agent.asynchEventDone(ctx, eventNameFormatted, null, errorObject);
      	*/
      	storage.set('ctx', ctx);
      }

    }
    function afterHandle(obj, args) {
  	  // if (ctx != null) agent.asynchEventFinish(ctx);
    }

    // Support send_command(com, [arg, cb]) and send_command(com, [arg], cb)
    var callbackIndex = args.length - 1;
    if (typeof args[callbackIndex] === 'function') {
      proxy.callback(args, callbackIndex, handle, afterHandle);
    } else {
      // Hack to support optional functions by adding noop function when
      // blank
      callbackIndex = input.length - 1;
      if (typeof input[callbackIndex] !== 'function') {
        input.push(function() {});
        callbackIndex += 1;
      }
      proxy.callback(input, callbackIndex, handle, afterHandle);
    }

  });
};


function getMethodsWithProbes() {
    var mt = new Object;
    mt[0] = 'redis#send_command';
    return mt;
}

module.exports = function (redis) {
    this.targetMod = redis;
};

module.exports.instrument = instrument.bind(module.exports);

module.exports.getMethodsWithProbes = getMethodsWithProbes;



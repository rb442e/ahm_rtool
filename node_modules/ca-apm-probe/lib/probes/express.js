/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

var path = require('path');
var agent = require('../agent');
var proxy = require('../proxy');

var util = require('util');
var logger = require("../logger.js");

var logExpressVersionOnce = false;
var targetModule = new Object;

module.exports = function (express) {

    targetModule.express = express;
    targetModule.methodMap = getMethodsWithProbes();
    var methodMap = targetModule.methodMap;

    function routeHook(obj, args, storage) {

        if (methodMap[0] == "skip_instrument") {
            return;
        }

        var path = obj.path;
        var req = args[0];
        var res = args[1];

        var eventNameFormatted = 'route.dispatch';
        var ctx = storage.get('ctx') || req.__CA_ctx;

        if (logger.isDebug()) {
            if (ctx) {
                logger.debug('%s[%d %d %d]: path - %s', eventNameFormatted, ctx.txid, ctx.lane, ctx.evtid, path);
            }
            else {
                logger.debug('%s - no context', eventNameFormatted);
                logger.debug((new Error('No context')).stack);
            }
        }

        ctx = agent.asynchEventStart(ctx, eventNameFormatted, {
            route: path,
            http_method: req.method
        });
        storage.set('ctx', ctx);

        var errorObject = new Object();

        var end_save = res.end;
        res.end = function () {
            if (res.finished === false && ctx) {
                ctx = agent.asynchEventDone(ctx, eventNameFormatted, null,
                    errorObject);

                if (ctx) {
                    agent.asynchEventFinish(ctx);
                }
            }

            end_save.apply(res, arguments);
        };
    }

    //Check for Express Version
    if (express.Route.prototype.dispatch) {
        if (logExpressVersionOnce == false) {
            logger.info('Express 4.x Routing Mechanism');
            logger.info('Loading Express probe');
            logExpressVersionOnce = true;
        }
        proxy.before(express.Route.prototype, 'dispatch', routeHook);
    }
    else if (logExpressVersionOnce == false) {
        logger.info('Expecting Express 4.x Routing Mechanism');
        logExpressVersionOnce = true;
    }

};


function getMethodsWithProbes() {
    if (!targetModule.methodMap) {
        var mt = new Object;
        mt[0] = 'route#dispatch';
        targetModule.methodMap = mt;
    }
    return targetModule.methodMap;
}

function instrument(methodMap) {
    targetModule.methodMap = methodMap;
}

module.exports.getMethodsWithProbes = getMethodsWithProbes;

module.exports.instrument = instrument.bind(module);


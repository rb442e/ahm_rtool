
/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

var net = require('net');
var os = require('os');
var path = require('path');
var fs = require('fs');
var util = require('util');
var semver = require('semver');
var logger = require("./logger.js");
var config = require('../config.json');
var probeUtil = require('./utils/common-utils');

var virtualstack = require('./virtualstack');
var collectorMsg = require("./collectormsg");

var pid = process.pid;
var instanceId = util.format('%s-%s', os.hostname(), pid);
var maxPingDelay = config.maxPingDelay || 15000;
var lastPingResponseTime = new Date().getTime();

var collectorHostDefault = 'localhost';
var collectorPortDefault = 5005;

var buff = [];
var currBuffSize = 0;
var maxAllowedBuffSize = 50000;
var buffFull = false;

var probeNameDefault = 'NodeApplication';

var currentHost = collectorHostDefault;
var currentPort = collectorPortDefault;

var currentProbeName = probeNameDefault;

var commandClient = null;
var dataClient = null;
var isCommandConnected = false;
var isDataConnected = false;

var speakPingProbeTimer = null;

var ArfMessageParser = require('./arf-parser').ArfMessageParser;
var arfMessageParser = null;


var logTraceEventStartFlag = true;
var logTraceEventEndFlag = true;
var logMetricsSendFlag = true;

// latest arf protocol version this probe complies to
var ARFP_VERSION = '1.1.0';

// minimum compatible collector version for metric reporting purpose
var METRICS_COMPATIBILITY = { minCollectorVersion: '10.5.2', minArfpVersion: '1.1.0' };
var metricsEnableDelay = 5000;
var metricsReportingEnabled = false;
var checkMetricsCompat = config.metrics.enabled && config.metrics.checkCompatibility;

var dataConnMsg = function () {
	var object = {
		op: 'dataConn',
		probe: 'nodejs',
		ver: ARFP_VERSION,
		pid: pid,
		instid: instanceId
	};
	return object;
};

var commandConnMsg = function () {
	var object = {
		op: 'commandConn',
		probe: 'nodejs',
		ver: ARFP_VERSION,
		instid: instanceId,
		pgm: currentProbeName,
		prms: { appName: resolveAppName() }
	};

	var hostName = resolveHostName();
	if (hostName)
		object.prms.hostName = hostName;

	var containerId = require('./find-container-id')();
	if (containerId)
		object.prms.containerId = containerId;

	return object;
};

var arfMsg = function () {
	var object = {
		op: 'arf'
	};
	return object;
};

var resolveHostName = function () {
	var hostNames = [];
	// host name from env variable
	hostNames[0] = process.env.CA_APM_HOSTNAME;

	// from config file
	hostNames[1] = config.hostName ? probeUtil.resolveEnv(config.hostName) : null;

	for (var i = 0; i < hostNames.length; i++) {
		if (hostNames[i]) {
			logger.debug("Host Name Detection choosing the name: " + hostNames[i]);
			return hostNames[i];
		}
	}

	return null;
};

var resolveAppName = function () {
	var appNames = [];
	// app name from env variable
	appNames[0] = process.env.CA_APM_APPNAME;

	// from config file
	appNames[1] = config.appName ? probeUtil.resolveEnv(config.appName) : null;

	// app name from application
	appNames[2] = probeUtil.findAppName();

	// default app name
	appNames[3] = 'NodeApplication';

	for (var i = 0; i < appNames.length; i++) {
		if (appNames[i]) {
			logger.debug("App Name Detection choosing the name: " + appNames[i]);
			return appNames[i];
		}
	}

	return null;
};

module.exports.start = start;

function connectCommandClient(host, port) {
	var client = net.connect(port, host, function () {
		logger.info('Command connection established with collector agent listening on host: %s, port: %d', host, port);
		isCommandConnected = true;
		logTraceEventStartFlag = true;
		logTraceEventEndFlag = true;
		logMetricsSendFlag = true;
		// we need to wait for agent configuration message
		setTimeout(checkMetricReportingStatus, metricsEnableDelay);

		client.write(generateMsg(commandConnMsg()));
		sendDataConnMsg();
		speakPingProbeTimer = setInterval(speakPingProbe, 2000);
	});
	client.on('end', function () {
		logger.info('Command connection disconnected');
		isCommandConnected = false;
	});

	arfMessageParser = new ArfMessageParser();
	// pass data to arf parser
	client.pipe(arfMessageParser);

	arfMessageParser.on('arf-message', function (message) {
		message = message.trim();

		if (message && message.length > 0) {
			try {
				processSingleMessage(message);
			}
			catch (e) {
				logger.debug('got exception: %s while processing message: %s', e.message, message);
			}
		}
	});

	return client;
}

function closeCommandClient() {
	/*Clear the speakPingProbeTimer since the Command Connection has been closed.
	No need to check now if the Collector is sending Speak messages or not.
	*/
	isCommandConnected = false;
	clearInterval(speakPingProbeTimer);
	if (commandClient) {
		commandClient.unpipe();
		commandClient.removeAllListeners();
		commandClient.destroy();
		delete commandClient;
		commandClient = null;
	}
}

function reconnectCommandClient() {
	setTimeout(function () {

		commandClient = connectCommandClient(currentHost, currentPort);
		commandClient.on('error', function (error) {
			logger.debug('[Command Conn Error]' + error);
			closeCommandClient();
			reconnectCommandClient();
		});
		commandClient.on('close', function () {
			logger.info('Command connection Closed');
			closeCommandClient();
			reconnectCommandClient();
		});
	}, 2000);
}

function start(opts) {

	currentHost = opts.collectorAgentHost || collectorHostDefault;
	currentPort = opts.collectorAgentPort || collectorPortDefault;
	currentProbeName = opts.probeName || probeNameDefault;

	logger.debug('Trying to connect with collector agent listening on host: %s, port: %d', currentHost, currentPort);

	commandClient = connectCommandClient(currentHost, currentPort);
	commandClient.on('error', function (error) {
		logger.info('[Command Conn Error]' + error);
		closeCommandClient();
		reconnectCommandClient();
	});
	commandClient.on('close', function () {

		closeCommandClient();
		reconnectCommandClient();
	});

}


function processSingleMessage(message) {
	if (message.indexOf('speak') != -1) {
		commandClient.write(generateMsg(arfMsg()));
		lastPingResponseTime = new Date().getTime();
		logger.debug("Sent reply for 'speak' message received. lastPingResponseTime updated to: %d", lastPingResponseTime);

	} else {
		processConfigMessage(message);
	}
}

// processes configuration message received from collector agent
function processConfigMessage(message) {
	var obj = JSON.parse(message);

	if (obj != null && obj.op == 'config') {
		if (obj.cmd == 'require') {
			logger.debug("received pbd configuration message for module: %s", obj.mod);

			var mod = obj.mod;
			var methodMap = obj.prms;
			logger.debug("module method map: %s", methodMap[0]);
			probeMod = CAAPMPROBE.getFromProbeMap(obj.mod);

			if (probeMod != null && probeMod.instrument != undefined && probeMod.instrument != null) {
				probeMod.instrument(methodMap);
			}
		} else if (obj.msg) {
			if (typeof obj.msg === 'string') {
				var m = JSON.parse(obj.msg);

				// collector version 10.5.2
				if (m.collector)
					processCollectorVersion(m.collector.version);
			}
		} else if (obj.cmd == 'version') {
			// collector version 10.7 and later
			var params = obj.prms;

			if (params.collector)
				processCollectorVersion(params.collector);
			if (params.arfp)
				processArfpVersion(params.arfp);
		}
	}
}

function processCollectorVersion(version) {
	logger.info("Probe connected to collector agent version: %s", version);

	try {
		if (checkMetricsCompat && semver.gte(version, METRICS_COMPATIBILITY.minCollectorVersion)) {
			metricsReportingEnabled = true;
		}
	}
	catch (e) {
		// ignore
	}
}

function processArfpVersion(version) {
	logger.debug("Collector agent implements ARF protocol version: %s", version);

	if (checkMetricsCompat && semver.gte(version, METRICS_COMPATIBILITY.minArfpVersion)) {
		metricsReportingEnabled = true;
	}
}

//close the commandClient and dataClient if the speak message has not been received till the maxPingDelay time gap
function speakPingProbe() {

	var currentTime = new Date().getTime();
	//logger.info('current time millis %d', currentTime);

	if (lastPingResponseTime < (currentTime - maxPingDelay)) {
		logger.info('Timeout for Speak Message. Closing Command and Data Connections from Probe End.');

		if (commandClient != null && commandClient.readyState !== 'close') {
			//commandClient.removeAllListeners('close');
			commandClient.end();
			if (dataClient != null && dataClient.readyState !== 'close') {
				dataClient.end();
			}


		}


	}

}


var sendDataConnMsg = function (isReconnection) {



	dataClient = net.connect(currentPort, currentHost, function () {
		if (isReconnection) {
			logger.info('Data connection re-established with collector agent');
		}
		else {
			logger.info('Data connection established with collector agent');
		}

		isDataConnected = true;
		dataClient.write(generateMsg(dataConnMsg()));

		// report platform metrics once data connection is up
		// and collector agent compatibility has be verified
		setTimeout(reportPlatformMetrics, (metricsEnableDelay + 2000));
	});
	dataClient.on('data', function (data) {
		logger.info("Server data on Data Conn: %s", data.toString());
		//client.end();
	});
	dataClient.on('end', function () {
		logger.info('Data connection disconnected');
		isDataConnected = false;
	});
	dataClient.on('error', function (error) {
		logger.info('[Data Conn Error]' + error);
		isDataConnected = false;
	});
	dataClient.on('close', function () {
		logger.info('Data connection Closed');
		isDataConnected = false;

		setTimeout(function () {
			if (commandClient && commandClient.readyState.toString() === 'open') {
				dataClient.removeAllListeners('connect');
				sendDataConnMsg(true);
			}
			else {
				logger.info('Data Connection not re-established since Command Connection is down');
			}
		}, 2000);
	});


};


var generateMsg = function (object) {
	var origJson = JSON.stringify(object);
	return origJson + os.EOL;
};

function checkBufferSize(msg) {
	if (currBuffSize + msg.length > maxAllowedBuffSize)
		return 0;
	else return 1;
}


// Write the buffer to the socket every 500 msecs
setInterval(function () {
	if (buff.length > 0 && !buffFull) {
		dataClient.write(buff.join(os.EOL) + os.EOL);
		buff = [];
		currBuffSize = 0;
	}
	buffFull = false;
}, 500); // 500 msecs


function writeToSocket(msg) {
	var res = checkBufferSize(msg);
	if (res == 1) { // space still available
		buff.push(msg);
	}
	else {
		buffFull = true;
		dataClient.write(buff.join(os.EOL) + os.EOL);
		buff = [];
		currBuffSize = 0;
		buff.push(msg); // clear the buff is it exceeds capacity and push the new incoming message
	}
	currBuffSize += msg.length;
}


function startTrace(name, time, txid, evtid, params) {
	/*This method should convert the incoming invocationData to relevant object*/

	//Check to find if the command connection is up: Only then proceed with the further execution of this function
	if (commandClient == null || commandClient.readyState.toString() !== 'open') {
		if (logTraceEventStartFlag) {
			logger.info('Start Trace cannot be initiated since the command connection is down.');
			logTraceEventStartFlag = false;
		}
		return;
	}


	if (dataClient == null) {
		sendDataConnMsg();
	}

	var object = {
		op: 'fnC',
		fn: name,
		ts: time,
		tid: txid,
		seq: evtid
	};
	if (params && Object.keys(params).length > 0) {
		object.prms = params;
	}
	var msg = JSON.stringify(object);
	writeToSocket(msg);
}

function endTrace(name, time, txid, evtid, params, errormsg) {


	//Check to find if the command connection is up: Only then proceed with the further execution of this function
	if (commandClient == null || commandClient.readyState.toString() !== 'open') {
		if (logTraceEventEndFlag) {
			logger.info('End Trace cannot be initiated since the command connection is down.');
			logTraceEventEndFlag = false;
		}
		return;
	}

	if (dataClient == null) {
		sendDataConnMsg();
	}

	var object = {
		op: 'fnR',
		fn: name,
		ts: time,
		tid: txid,
		cseq: evtid
	};
	if (params && Object.keys(params).length > 0) {
		object.prms = params;
	}

	if (errormsg && Object.keys(errormsg).length > 0) {
		object.exc = errormsg;
	}

	var msg = JSON.stringify(object);
	writeToSocket(msg);

}

virtualstack.on('tracer-start', function (event) {
	startTrace(event.name, event.time, event.txid, event.evtid, event.params);
});
virtualstack.on('tracer-finish', function (event) {
	endTrace(event.name, event.time, event.txid, event.evtid, event.params, event.errormsg);
});

module.exports.startTrace = startTrace;
module.exports.endTrace = endTrace;

function sendRequire(event) {
	if (!isCommandConnected) {
		logger.debug('Cannot send require event as command connection is down.');
		defer(sendRequire, event);
		return;
	}

	if (!isDataConnected) {
		logger.debug('Cannot send require event as data connection is down.');
		defer(sendRequire, event);
		return;
	}

	var object = {
		op: 'require',
		mod: event.module
	};
	if (event.params) {
		if (Object.keys(event.params).length > 0) {
			object.prms = event.params;
		}
	}
	var msg = generateMsg(object);
	dataClient.write(msg);
	logger.debug("Sending " + msg);

}

function defer(f) { setTimeout(f.bind.apply(f, arguments), 2000); }

collectorMsg.on('send-require', function (event) {
	sendRequire(event);
});

collectorMsg.on('receive-require', function (event) {
	collectorMsg.receiveRequire(event);
});

collectorMsg.on('send-metric', function (metric) {
	sendMetricInternal(metric);
});

function sendMetricInternal(metric) {

	//Check to find if the command connection is up: Only then proceed with the further execution of this function
	if (commandClient == null || commandClient.readyState.toString() !== 'open') {
		if (logMetricsSendFlag) {
			logger.debug('Metrics cannot be sent since the command connection is down.');
			logMetricsSendFlag = false;
		}
		return;
	}

	if (dataClient == null) {
		sendDataConnMsg();
	}

	if (metricsReportingEnabled) {
		var msg = generateMsg(metric);
		logger.debug("sending: <%s>", msg);
		dataClient.write(msg);
	}
};

function reportPlatformMetrics() {
	var reporter = require('./metrics').getReporter();
	var envInfo = require('./envinfo');

	reporter.reportStringMetric('Node Version', process.version);
	reporter.reportStringMetric('Platform', envInfo.getPlatformInfo());
	if (envInfo.getProbePackage()) {
		reporter.reportStringMetric('Probe Version', envInfo.getProbePackage().version);
	}

	// report collector agent info
	reporter.reportStringMetric('Collector Host', currentHost);
	reporter.reportStringMetric('Collector Port', currentPort);
}

function checkMetricReportingStatus() {
	if (config.metrics.enabled && !metricsReportingEnabled) {
		if (!config.metrics.checkCompatibility) {
			metricsReportingEnabled = true;
		} else {
			logger.warn("Probe has disabled runtime metrics reporting because it could not validate Collector Agent version. Please check probe compatibility guide.")
		}
	}
}

module.exports.sendMetric = sendMetricInternal;


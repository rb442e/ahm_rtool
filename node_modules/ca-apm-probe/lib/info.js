 
/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

var cpuinfo = require('./cpuinfo');
var proxy = require('./proxy');
var config = require('../config.json');
var os = require('os');
var gc = (require('gc-stats'))();


var sustainabilityMetricsEnabled = config.sustainabilityMetricsEnabled || true;


var osScope = os.hostname();
var processScope = osScope + ' - Process[' + process.pid + ']';

var agent;
var gcstats = [];
var timebase;

exports.init = function(agent_) {
  agent = agent_;

  gc.on('stats', function (stats) {
    var len = gcstats.push(stats.after.usedHeapSize);
    var total = gcstats.reduce(function(a, b) { return a + b });
    var baseline = total / len;
    agent.metric(processScope, 'GC Full. V8 heap used', baseline, 'Bytes');

    if (len > 10) {
      gcstats.shift();  // Sliding window.
    }
  

  // collect updated heap metrics after gc
  collectHeap();
  });

  timebase = Date.now();
  collect();
};

exports.poll = function() {
  collect();
  connectionInfo();
  collectHeap();
  sustainabilityInfo();
};

function collectHeap() {
  agent.metric(processScope, 'Heap Data', process.memoryUsage(), 'Bytes');
}

function connectionInfo() {
  // FIXME(bnoordhuis) Tracks only one HTTP server per process and it's not
  // very deterministic what server that is...
  var server = agent.httpServer;
  if (server == null) return;
  var kContextPropertyName = '__CA_APM_PROBE_HTTP_CONTEXT__';
  var context = server[kContextPropertyName];
  var curr = context.connectionCounts[0];
  var prev = context.connectionCounts[1];
  context.connectionCounts[0] = 0;
  context.connectionCounts[1] = curr;
  if (server.getConnections) {
    server.getConnections(callback);
  } else {
    callback(null, server.connections || server._connections || 0);
  }
  function callback(err, conns) {
    if (err) return;
    var now = Date.now();
    var tps = curr / (now - timebase) / 1000;
    timebase = now;
    var metrics = [conns, tps, curr, prev];
    agent.metric(processScope, 'Connections', metrics, '');
  }
}

function collect() {
  cpuinfo.cpuutil(function(percent_proc, percent_user, percent_syst) {
    agent.metric(processScope, 'CPU util', percent_proc, '%');
    agent.metric(processScope, 'CPU util stime', percent_syst, '%');
    agent.metric(processScope, 'CPU util utime', percent_user, '%');
  });
}

function sustainabilityInfo() {
  if (sustainabilityMetricsEnabled) {
    //metrics = [countPerInterval, countTotal];
    var metrics = proxy.sustainabilityData.collectMetrics();
    agent.metric(processScope, 'Sustainability', metrics, '');
  }
}
 
/**
 * Copyright (c) 2015 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and proprietary and
 * shall not be duplicated, used, disclosed or disseminated in any way except as authorized
 * by the applicable license agreement, without the express written permission of CA. All
 * authorized reproductions must be marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY
 * OF ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

var winston = require('winston');
var fs = require('fs');
var path = require('path');

var configFile='../config.json';
var logFile;
var logLevel = 'info';
var isDebugEnabled = false;
var isVerboseEnabled = false;
var isPathAbsolute = false;
var logToConsole = false;
var isDeepStackTraceEnabled = false;
var savedDeepStackTraceLimit = -1;
var lastConfigRead = new Date(0);
var configReloadInterval = require(configFile).configReloadInterval || 60000;
var probeNameResolver = require('./probename-resolver');

function reloadConfiguration() {

	var resolved = require.resolve(configFile);
	var stats = fs.statSync(resolved);
	if (!stats || stats.ctime.getTime() <= lastConfigRead.getTime() ) {
		return;
	}

	if (logger) logger.info('Reloading log config from %s.', resolved);
	lastConfigRead = stats.ctime;
	delete require.cache[resolved];
	var config = require(configFile);

	if (config.logging) {
		if(config.logging.logFile != "") {
			logFile = config.logging.logFile;
			if(isAbsolute(config.logging.logFile)){
				isPathAbsolute = true;
			}
			else {
				logFile = __dirname + "/" + config.logging.logFile;
			}
			if(logFile.match("\\$\\{.*\\}")) {
				if(probeNameResolver.getProbeName()) {
					logFile = logFile.replace(new RegExp("\\$\\{.*\\}"), probeNameResolver.getProbeName());
				}
				else {
					logFile = logFile.replace(new RegExp("\\$\\{.*\\}"), "NodeApplication");
				}
			}
		}
		else {
			if(probeNameResolver.getProbeName()) {
				logFile = __dirname + "/../logs/Probe-" + probeNameResolver.getProbeName() + ".log";
			}
			else{
				logFile = __dirname + "/../logs/Probe-" + "NodeApplication.log";
			}
		}

		if (config.logging.logLevel.toLowerCase() !== logLevel.toLowerCase()) {
			var prevLogLevel = logLevel;
			logLevel = config.logging.logLevel.toLowerCase();

			if (logger) {
				logger.transports.file.level = logLevel;
				logger.info('log level changed %s -> %s', prevLogLevel, logLevel);
			}
		}
		var isDeepStackTraceFlag = (config.logging.deepStackTraceEnabled == undefined) ? false : config.logging.deepStackTraceEnabled;
		if (isDeepStackTraceFlag) {
			if (!isDeepStackTraceEnabled) {
				savedDeepStackTraceLimit = Error.stackTraceLimit;
				Error.stackTraceLimit = Infinity;
				isDeepStackTraceEnabled = true;
			}
		}
		else {
			if (isDeepStackTraceEnabled && Error.stackTraceLimit == Infinity && savedDeepStackTraceLimit != -1) {
				Error.stackTraceLimit = savedDeepStackTraceLimit;
			}
			isDeepStackTraceEnabled = false;
		}
	}
	if (logLevel === 'debug') {
			isDebugEnabled = true;
			isVerboseEnabled = true;
	}

	if (logLevel === 'verbose') {
		isVerboseEnabled = true;
	}	
} 

function isAbsolute(p) {
    return path.normalize(p + '/') === path.normalize(path.resolve(p) + '/');
}

function checkPermissions(){

	if(!logger) {
		return;
	}
	try {
		var stats = fs.statSync(logFile);
	} 
	catch(err) {
		// file does not exist, so no need to check for permissions
		return;
	}
	// logFile has write permission
	if (stats["mode"] & 200) { 
		logger.transports.console.silent = true;
	} 
	else {	
		logger.transports.console.silent = false;
		logger.transports.file.silent = true;
		logger.info("Log file "+logFile+" does not have write permissions. Hence logging to console");
		logToConsole = true;
	}
}

function createLogsFolderIfDontExist(){
	
	try{
		fs.mkdirSync(path.dirname(logFile));
	} catch(e) {
		if(e.code == 'EEXIST') {
			return;
		}
		else { 
			// creation threw other error like access denied or something, so log to console in that case.
			logger.transports.console.silent = false;
			logger.transports.file.silent = true;
			logger.info("Log folder "+path.dirname(logFile)+" cannot be created. Hence logging to console");
			logToConsole = true;
		}
	}
}

function logFromBuffer() {
	var buffer = probeNameResolver.getBuffer();
	if(buffer) {
		var infoArr = buffer.info;
		for(var entry in infoArr) {
			logger.info(infoArr[entry]);
		}
		if(logger.isDebug()) {
			var debugArr = buffer.debug;
			for(var entry in debugArr) {
				logger.debug(debugArr[entry]);
			}
		}
	}
}

var getTimeStamp = function() { 
	var now = new Date(),
    tzo = -now.getTimezoneOffset(),
    dif = tzo >= 0 ? '+' : '-',
    pad = function(num) {
        var norm = Math.abs(Math.floor(num));
        return (norm < 10 ? '0' : '') + norm;
    };
return now.getFullYear() 
    + '/' + pad(now.getMonth()+1)
    + '/' + pad(now.getDate())
    + ' ' + pad(now.getHours())
    + ':' + pad(now.getMinutes()) 
    + ':' + pad(now.getSeconds()) 
    + ':' + pad(now.getMilliseconds())
    + dif + pad(tzo / 60) 
    + ':' + pad(tzo % 60);
};

reloadConfiguration();

var transport = new winston.transports.File({
    level: logLevel,
    filename: logFile,
    handleExceptions: false,
    json: false,
    maxsize: 5242880, //5MB
    maxFiles: 5,
    colorize: false,
    timestamp: getTimeStamp
});

var consoleTransport = new winston.transports.Console({
	 level: logLevel,
	 name: 'console',
	 silent: true,
	 colorize: true,
	 timestamp: getTimeStamp
});

var logger = new winston.Logger({
	
	transports: [
	             transport,
	             consoleTransport
	         ],
});

createLogsFolderIfDontExist();
checkPermissions();

console.log("[CA APM PROBE] monitoring application with pid "+ process.pid);
if(!logToConsole && logLevel.toLowerCase() !== 'disabled') {
	console.log("[CA APM PROBE] Log file location: " + path.normalize(logFile));
}

logger.isDebug = function(){
	return isDebugEnabled;
};

logger.isVerbose = function(){
	return isVerboseEnabled;
};

logger.setLabel = function(str) {
	transport.label = str;
};

logFromBuffer();

var disableLogger =  {
	debug: function(){},
	verbose: function(){},
	info: function(){},
	error: function(){},
	fatal: function(){},
	log: function(){},
	warn: function(){},
	isDebug: function() { return false; },
	isVerbose: function() { return false; },
	setLabel: function() {}		
};

var wrappedLogger = {
		debug: function(){ if (isDebugEnabled) logger.debug.apply(logger, arguments); },
		verbose: function(){ if (isVerboseEnabled) logger.verbose.apply(logger, arguments); },
		info: function(){ logger.info.apply(logger, arguments); },
		error: function(){ logger.error.apply(logger, arguments); },
		fatal: function(){ logger.fatal.apply(logger, arguments); },
		log: function(){ logger.log.apply(logger, arguments); },
		warn: function(){ logger.warn.apply(logger, arguments); },
		isDebug: function() { return isDebugEnabled; },		
		isVerbose: function() { return isVerboseEnabled; },		
		setLabel: function(str) { logger.setLabel(str); }		
};

if (logLevel.toLowerCase() === 'disabled') {
	module.exports = disableLogger;
}
else {
	winston.emitErrs = true;
	module.exports = wrappedLogger;
}

setInterval(reloadConfiguration, configReloadInterval);